# love
5/3

代码分层，非必要不需要使用interface。
api做的尽量小
少用else
通过断言错误来做错误判断



5/2

slice的赋值机制是复制机制，range，append都是在原有的基础上新增一个内存堆，再把旧的值传进去
所以一旦扩增了数组切片，旧的指针就会指向过去的内存堆导致内存溢出，所以要谨慎使用指针
byte是3字节的utf-8
遍历map时，返回的的是随机的顺序，可以使用sort包
一、耦合
1、耦合是指两个或两个以上的体系或两种运动形式间通过相互作用而彼此影响以至联合起来的现象。

2、在软件工程中，对象之间的耦合度就是对象之间的依赖性。对象之间的耦合越高，维护成本越高，因此对象的设计应使类和构件之间的耦合最小。

3、分类：有软硬件之间的耦合，还有软件各模块之间的耦合。耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。

二、解耦

1、解耦，字面意思就是解除耦合关系。

2、在软件工程中，降低耦合度即可以理解为解耦，模块间有依赖关系必然存在耦合，理论上的绝对零耦合是做不到的，但可以通过一些现有的方法将耦合度降至最低。

3、设计的核心思想：尽可能减少代码耦合，如果发现代码耦合，就要采取解耦技术。让数据模型，业务逻辑和视图显示三层之间彼此降低耦合，把关联依赖降到最低，而不至于牵一发而动全身。原则就是A功能的代码不要写在B的功能代码中，如果两者之间需要交互，可以通过接口，通过消息，甚至可以引入框架，但总之就是不要直接交叉写。

4、观察者模式：观察者模式存在的意义就是「解耦」，它使观察者和被观察者的逻辑不再搅在一起，而是彼此独立、互不依赖。比如网易新闻的夜间模式，当用户切换成夜间模式之后，被观察者会通知所有的观察者「设置改变了，大家快蒙上遮罩吧」。QQ消息推送来了之后，既要在通知栏上弹个推送，又要在桌面上标个小红点，也是观察者与被观察者的巧妙配合。

interface定义行为（behavior）比方说speak，而不是人，事务，地点
不要抽象化输入函数，一个函数有十几个输入也ok


5/1
每个堆和每个堆都不能相互动态引用 堆大小不够了可以每次扩展到一个新堆
垃圾回收：黑白灰 所有堆和内容都为白 扫描没有被调用的清除掉 保留黑和灰
堆类似于静态列表 栈类似于链表 
m，p类似于核心或者虚拟内核 一个p上可以携带n个gorotine
https://tonybai.com/2020/03/10/visualizing-memory-management-in-golang/

4/29
var 类型和大小是全部! conversion，使用int is important!
struct 数据类型的排序影响整个struct内存的大小 可读性（相似放在一起）其次是性能 
struct使用conversion转化结构（显式） a=b隐式转换形式（不推荐） 
mental model

4/26
闭包 interface 反射 gorotina chanel

4/25
fallthrough  elseif continua map{xx}interface copy

2022年
